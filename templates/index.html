<!doctype html>
<meta charset="utf-8">
<title>BlockDAG Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="https://blockdag.network/images/presskit/Symbol.svg">
<style>
  :root { --bg:#0b1020; --card:#121a33; --text:#e7eaf6; --muted:#9aa4c7; --ok:#25d366; --bad:#ff5370; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  .card{background:var(--card);border-radius:16px;box-shadow:0 4px 18px rgba(0,0,0,.25);padding:16px}
  .title{font-weight:600;font-size:20px;margin-bottom:10px;display:flex;align-items:center;gap:10px}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px;margin-top:16px}
  .kvs{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px;margin-top:8px}
  .kvs.node-stats{display:flex;flex-wrap:nowrap;gap:8px;overflow-x:auto}
.kvs.node-stats .kv{flex:1 0 auto;min-width:0}
  .kv{background:rgba(255,255,255,.04);border-radius:12px;padding:10px}
  .kv .k{color:var(--muted);font-size:12px}
  .kv .v{font-size:18px;margin-top:4px}
  canvas{width:100%;height:260px;background:rgba(0,0,0,.12);border-radius:12px;padding:8px}
  .chart-value-tag{position:absolute;bottom:8px;right:12px;font-size:12px;color:var(--muted);background:rgba(0,0,0,.45);padding:2px 8px;border-radius:999px;font-variant-numeric:tabular-nums;pointer-events:none;white-space:nowrap}
  .pill{display:inline-block;border-radius:999px;padding:6px 14px;font-size:12px;background:rgba(255,255,255,.08);line-height:1;font-weight:600;transition:background .2s,color .2s}
  .stack{display:grid;grid-template-columns:1fr;gap:16px}
  .header{display:flex;align-items:center;gap:10px;justify-content:space-between;margin-bottom:16px;padding:0 8px;}
  .header img{border-radius:6px;height:36px;width:36px}
/* node-controls-toolbar */
.node-ctrls{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));column-gap:12px;row-gap:8px;margin-top:12px;align-items:end}
.node-ctrls .btn{padding:.4rem .6rem;border:1px solid #3a4a7a;border-radius:.6rem;background:transparent;color:inherit;cursor:pointer}
.node-ctrls .btn:disabled{opacity:.5;cursor:not-allowed}
.node-ctrls .sp{opacity:.7;margin:0 .2rem;grid-column:1/-1}
.node-ctrls label{display:flex;flex-direction:column;gap:4px;font-size:11px;text-transform:uppercase;letter-spacing:.06em}
.node-ctrls label span{opacity:.7}
.node-ctrls input{background:transparent;border:1px solid #3a4a7a;border-radius:.6rem;padding:.35rem .6rem;color:inherit}
.node-ctrls select{width:100%;appearance:none;background-color:rgba(255,255,255,.06);border:1px solid #3a4a7a;border-radius:.6rem;padding:.35rem .6rem;color:var(--text);background-image:linear-gradient(45deg,transparent 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,transparent 50%);background-position:calc(100% - 18px) calc(50% - 3px),calc(100% - 12px) calc(50% - 3px);background-size:6px 6px;background-repeat:no-repeat;padding-right:1.8rem}
.node-ctrls select option{background-color:var(--card);color:var(--text)}
#nodeControlsCard .node-ctrls--node{display:grid;grid-template-columns:minmax(220px,1.4fr) minmax(200px,1fr) minmax(160px,.9fr) minmax(140px,auto) minmax(200px,.9fr) minmax(160px,.7fr);column-gap:12px;row-gap:4px;align-items:end}
#nodeControlsCard .node-ctrls__field{display:flex;flex-direction:column;gap:4px;min-width:0}
#nodeControlsCard .node-ctrls__field span{opacity:.7}
#nodeControlsCard .node-ctrls__field select{width:100%}
#nodeControlsCard .node-ctrls__actions{display:flex;gap:8px;flex-wrap:nowrap}
#nodeControlsCard .node-ctrls__actions .btn{flex:1 1 auto;min-width:120px}
#nodeControlsCard .node-ctrls__actions--chain .btn{min-width:100px}
#nodeControlsCard .node-ctrls__field--auto input{width:100%;text-align:center}
#nodeControlsCard .node-ctrls__btn--auto-apply{width:100%;min-width:110px}
#nodeControlsCard .node-ctrls__btn--auto-disable{min-width:110px}
#nodeControlsCard .node-ctrls__meta{align-self:center;justify-self:end;text-align:right;margin:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#nodeControlsCard .node-ctrls__meta--status{justify-self:start;text-align:left}
#nodeControlsCard .node-ctrls__row{grid-column:1/-1;display:grid;gap:6px;align-items:end}
#nodeControlsCard .node-ctrls__row--chain{margin-top:2px;grid-template-columns:minmax(240px,1.4fr) minmax(220px,auto) minmax(240px,1fr)}
#nodeControlsCard .node-ctrls__field--chain{display:flex;flex-direction:column;gap:4px;min-width:0}
#nodeControlsCard .node-ctrls__field--chain span{opacity:.7}
#nodeControlsCard .node-ctrls__field--chain select{width:100%}
#nodeControlsCard .node-ctrls__actions--chain{display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:nowrap}
#nodeControlsCard .node-ctrls__actions--chain .btn{min-width:100px}
#nodeControlsCard .node-ctrls__status{display:none}
@media (max-width:1100px){
  #nodeControlsCard .node-ctrls--node{grid-template-columns:repeat(auto-fit,minmax(260px,1fr));align-items:stretch}
  #nodeControlsCard .node-ctrls__actions{flex-wrap:wrap}
  #nodeControlsCard .node-ctrls__actions .btn{flex:1 1 120px}
  #nodeControlsCard .node-ctrls__btn--auto-apply,#nodeControlsCard .node-ctrls__btn--auto-disable{width:100%;min-width:0}
  #nodeControlsCard .node-ctrls__meta{grid-column:1/-1;justify-self:start;text-align:left;white-space:normal}
  #nodeControlsCard .node-ctrls__row--chain{grid-template-columns:repeat(auto-fit,minmax(240px,1fr))}
  #nodeControlsCard .node-ctrls__status--chain{text-align:left}
  #nodeControlsCard .node-ctrls__actions--chain{justify-content:flex-start;flex-wrap:wrap}
  #nodeControlsCard .node-ctrls__actions--chain .btn{flex:1 1 140px}
}
#nodeControlStatus{min-height:1.2em;opacity:0;transition:opacity .2s ease}
#nodeContainerDetails{opacity:.8;text-align:right}
#ctlStatus{min-width:120px;display:inline-block;opacity:1}
  .activity-head{display:flex;flex-wrap:wrap;gap:16px;align-items:flex-start;margin-bottom:8px}
  .activity-head-col{flex:1 1 320px}
  .activity-head-col--controls{flex:1 1 280px}
  .activity-head .title{margin-bottom:0}
  .activity-body{display:flex;flex-wrap:wrap;gap:16px;align-items:flex-start;margin-top:0}
.activity-kvs{flex:1 1 320px;display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px}
.activity-controls{flex:1 1 280px}
.activity-controls .node-ctrls{margin-top:0}
  .log-output{background:rgba(33,24,0,.45);border-radius:12px;padding:12px;margin:0;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;line-height:1.4;white-space:pre-wrap;word-break:break-word;max-height:252px;overflow-y:auto;border:1px solid rgba(255,167,38,.35);color:#ffb74d;scrollbar-width:thin;scrollbar-color:#20263d rgba(255,255,255,0.16);}
  .log-output::-webkit-scrollbar{width:8px;height:8px}
  .log-output::-webkit-scrollbar-track{background:rgba(255,255,255,0.16);border-radius:8px}
  .log-output::-webkit-scrollbar-thumb{background:#20263d;border-radius:8px}
.logs-card details{display:block}
.logs-card summary{cursor:pointer;list-style:none;display:flex;align-items:center;justify-content:space-between;gap:12px;font-weight:600;font-size:18px;margin-bottom:12px}
.logs-card summary::-webkit-details-marker{display:none}
.log-toggle-wrapper{display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)}
.log-toggle-icon{display:inline-block;transition:transform .2s ease}
.logs-card details[open] .log-toggle-icon{transform:rotate(0deg)}
.logs-card details:not([open]) .log-toggle-icon{transform:rotate(-90deg)}
</style>

<div class="wrap">
  <!-- Header -->
  <div class="header">
    <div style="display:flex;align-items:center;gap:10px">
      <img src="https://blockdag.network/images/presskit/Symbol.svg" alt="BlockDAG Logo">
      <h1 style="margin:0;font-size:22px;">BlockDAG Node Dashboard</h1>
    </div>
    <span id="healthLine" class="pill">Loading…</span>
  </div>

  <div class="stack">
    <!-- Node Stats -->
    <div class="card">
      <div class="title">Node Stats</div>
      <div class="kvs node-stats">
        <div class="kv"><div class="k">local height</div><div class="v" id="vLocalHeight">—</div></div>
        <div class="kv"><div class="k">remote height</div><div class="v" id="vRemoteHeight">—</div></div>
        <div class="kv"><div class="k">state sync</div><div class="v" id="vStateSync">—</div></div>
        <div class="kv"><div class="k">ETA to full sync</div><div class="v" id="vEtaSync">—</div></div>
        <div class="kv"><div class="k">peers</div><div class="v" id="vPeers">—</div></div>
        <div class="kv"><div class="k">rpc latency (ms)</div><div class="v" id="vLat">—</div></div>
        <div class="kv"><div class="k">last seen</div><div class="v" id="vLast">—</div></div>
        <div class="kv"><div class="k">uptime</div><div class="v" id="vUptime">—</div></div>
      </div>
    </div>

    <div class="card" id="nodeControlsCard" hidden>
      <div class="title">Node Controls</div>
      <div class="node-ctrls node-ctrls--node">
        <label class="node-ctrls__field node-ctrls__field--container">
          <span>Container</span>
          <select id="nodeContainerSelect" disabled>
            <option value="">Loading…</option>
          </select>
        </label>
        <div class="node-ctrls__actions node-ctrls__actions--container">
          <button class="btn" data-node-action="restart" id="btnContainerRestart" disabled>Restart</button>
        </div>
        <label class="node-ctrls__field node-ctrls__field--auto">
          <span>Auto restart (hrs)</span>
          <input type="number" id="autoRestartHours" min="1" step="1" value="6">
        </label>
        <button class="btn node-ctrls__btn node-ctrls__btn--auto-apply" data-node-action="auto_enable" id="btnAutoRestartEnable" disabled>Apply</button>
        <button class="btn node-ctrls__btn node-ctrls__btn--auto-disable" data-node-action="auto_disable" id="btnAutoRestartDisable" disabled>Disable</button>
        <span class="node-ctrls__meta" id="nodeContainerDetails">Auto restart: —</span>
        <span class="node-ctrls__meta node-ctrls__meta--status" id="nodeControlStatus"></span>
        <div class="node-ctrls__row node-ctrls__row--chain">
          <label class="node-ctrls__field node-ctrls__field--chain">
            <span>Chain backups</span>
            <select id="chainBackupSelect" disabled>
              <option value="">Loading…</option>
            </select>
          </label>
          <div class="node-ctrls__actions node-ctrls__actions--chain">
            <button class="btn" data-node-action="chain_restore" id="btnChainRestore" disabled>Restore Selected</button>
            <button class="btn" data-node-action="chain_delete" id="btnChainDelete" disabled>Delete Selected</button>
            <button class="btn" data-node-action="chain_backup" id="btnChainBackup" disabled>Backup Now</button>
          </div>
        </div>
        <p class="node-ctrls__status node-ctrls__status--chain" id="chainControlStatus">Chain controls unavailable</p>
      </div>
    </div>

    <!-- Activity Totals -->
    <div class="card">
      <div class="activity-head">
        <div class="activity-head-col">
          <div class="title">Block Activity</div>
        </div>
        <div class="activity-head-col activity-head-col--controls">
          <div class="title">Chart Controls</div>
        </div>
      </div>
      <div class="activity-body">
        <div class="kvs activity-kvs">
          <div class="kv"><div class="k">mined (total)</div><div class="v" id="vMined">—</div></div>
          <div class="kv"><div class="k">processed (total)</div><div class="v" id="vProcessed">—</div></div>
          <div class="kv"><div class="k">sealed (total)</div><div class="v" id="vSealed">—</div></div>
        </div>
        <div class="activity-controls">
          <div class="node-ctrls" id="chartControls">
            <label>
              <span>Window (min)</span>
              <select id="chartWindowMinutes">
                <option value="1">1 min</option>
                <option value="5">5 min</option>
                <option value="10">10 min</option>
                <option value="20" selected>20 min</option>
                <option value="30">30 min</option>
                <option value="60">60 min</option>
              </select>
            </label>
            <label>
              <span>History Points</span>
              <select id="chartHistoryPoints">
                <option value="60">60 pts</option>
                <option value="120">120 pts</option>
                <option value="240" selected>240 pts</option>
                <option value="360">360 pts</option>
                <option value="480">480 pts</option>
              </select>
            </label>
            <button class="btn" id="btnApplyChartSettings">Apply</button>
            <span class="sp" id="ctlStatus"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Charts -->
    <div class="card">
      <div class="grid">
        <div><canvas id="heightChart"></canvas></div>
        <div><canvas id="peersChart"></canvas></div>
        <div><canvas id="latencyChart"></canvas></div>
        <div><canvas id="activityChart"></canvas></div>
      </div>
    </div>

    <!-- Recent Logs -->
    <div class="card logs-card">
      <details id="logsPanel" open>
        <summary>
          <span class="log-title">Recent Logs</span>
          <span class="log-toggle-wrapper">
            <span class="log-toggle-text">Hide</span>
            <span class="log-toggle-icon" aria-hidden="true">▼</span>
          </span>
        </summary>
        <pre id="logOutput" class="log-output" data-last-text="" aria-live="polite">Loading…</pre>
      </details>
    </div>

  </div>
</div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<!-- charts singleton wrapper -->
<script>
(function(){
  if (window.__ChartSingletonPatched) return;
  window.__ChartSingletonPatched = true;

  const _Chart = window.Chart;
  if (!_Chart) { console.warn("[charts] Chart.js not loaded yet; singleton wrapper will noop."); return; }

  const origCtor = _Chart.prototype.constructor;
  const origDestroy = _Chart.prototype.destroy;
  const store = (window.__charts = window.__charts || {});

  if (!_Chart.prototype.__singletonDestroyPatched){
    _Chart.prototype.destroy = function(){
      try{
        const id = this && this.canvas && (this.canvas.id || this.canvas.getAttribute("id"));
        if (id && store[id] === this){
          delete store[id];
        }
      }catch(e){}
      if (typeof origDestroy === 'function'){
        return origDestroy.apply(this, arguments);
      }
    };
    _Chart.prototype.__singletonDestroyPatched = true;
  }

  _Chart.prototype.constructor = function(ctx, cfg){
    try {
      const id = ctx && ctx.canvas && (ctx.canvas.id || ctx.canvas.getAttribute("id")) || null;
      if (id) {
        if (store[id]) {
          return store[id];
        }
        const inst = origCtor.apply(this, arguments);
        store[id] = inst;
        inst.__id = id;
        return inst;
      }
    } catch(e) {}
    return origCtor.apply(this, arguments);
  };
})();
</script>
<script>
const mkLine = (ctx, label, data, labels) => {
  if (!window.Chart) return null;
  const chart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets: [{ label, data, fill:false, tension:0.25, pointRadius:0, borderWidth:2 }] },
    options: {
      animation:false, responsive:true, maintainAspectRatio:false,
      scales:{ x:{ ticks:{display:false}}, y:{ beginAtZero:true } },
      plugins:{ legend:{ display:true } }
    }
  });
  chart._valueTag = null;
  return chart;
};

let charts = {};
const chartModes = {};
const activitySeriesLabels = {
  activity: 'Block Activity Rate (blk/s)',
  sync: 'Sync Rate (blk/s)',
};
const baseChartLabels = { peers: 'Peers', latency: 'RPC Latency (ms)' };
const NODE_CTRL_REFRESH_MS = 10000;
const nodeControlState = { enabled:false, containers:[], lastFetched:0, chainBackups:[], chainBackupsLastFetched:0, chainJob:null, chainEnabled:false };
let nodeControlPendingMessage = null;
let chainControlPendingMessage = null;
const AUTO_RESTART_DEFAULT_HOURS = 6;

function formatBytes(bytes){
  const num = Number(bytes);
  if (!Number.isFinite(num) || num < 0) return '';
  if (num === 0) return '0 B';
  const units = ['B','KB','MB','GB','TB'];
  let value = num;
  let unitIndex = 0;
  while (value >= 1024 && unitIndex < units.length - 1){
    value /= 1024;
    unitIndex++;
  }
  const digits = value >= 100 ? 0 : value >= 10 ? 1 : 2;
  return `${value.toFixed(digits)} ${units[unitIndex]}`;
}

function formatTimestamp(ts){
  if (!ts) return '';
  const date = new Date(ts);
  if (!Number.isFinite(date.getTime())) return '';
  return date.toLocaleString(undefined, { hour12:false });
}

function formatDuration(seconds){
  const total = Math.max(0, Math.floor(Number(seconds) || 0));
  const hrs = Math.floor(total / 3600);
  const mins = Math.floor((total % 3600) / 60);
  const secs = total % 60;
  const pad = value => String(value).padStart(2,'0');
  if (hrs > 0){
    return `${hrs}:${pad(mins)}:${pad(secs)}`;
  }
  return `${mins}:${pad(secs)}`;
}

function formatBackupNameDisplay(name){
  if (!name) return 'backup';
  const match = name.match(/(\d{8}-\d{6})/);
  if (match){
    return match[1];
  }
  return name.length > 32 ? `${name.slice(0, 16)}…${name.slice(-9)}` : name;
}

function buildChainJobMessage(job){
  if (!job) return '';
  if (job.active && job.type === 'backup'){
    const details = job.details || {};
    const name = formatBackupNameDisplay(details.path);
    const parts = [`Creating ${name}`];
    const started = job.started ? Date.parse(job.started) : NaN;
    if (Number.isFinite(started)){
      const elapsedSec = Math.max(0, (Date.now() - started) / 1000);
      parts.push(`${formatDuration(elapsedSec)} elapsed`);
    }
    const sizeVal = Number(details.size);
    if (Number.isFinite(sizeVal) && sizeVal >= 0){
      parts.push(formatBytes(sizeVal));
    }
    return parts.join(' · ');
  }
  return job.message || '';
}

const legendOffsetPlugin = {
  id: 'legendOffset',
  afterLayout(chart) {
    const cfg = chart.options?.plugins?.legendOffset;
    if (!cfg) return;
    const legend = chart.legend;
    if (!legend) return;
    const x = Number(cfg.x) || 0;
    if (x){
      legend.left += x;
      legend.right += x;
    }
  }
};
if (window.Chart && !window.__legendOffsetRegistered){
  try { window.Chart.register(legendOffsetPlugin); } catch(_) {}
  window.__legendOffsetRegistered = true;
}

function hexToRgba(hex, alpha){
  const match = /^#?([0-9a-f]{6})$/i.exec(hex || '');
  if (!match) return null;
  const value = parseInt(match[1], 16);
  const r = (value >> 16) & 255;
  const g = (value >> 8) & 255;
  const b = value & 255;
  const a = (typeof alpha === 'number' && !Number.isNaN(alpha)) ? alpha : 1;
  return `rgba(${r},${g},${b},${a})`;
}

function applyPillStyle(el, hexColor, alpha=0.25){
  if (!el) return;
  const bg = hexToRgba(hexColor, alpha);
  el.style.background = bg || 'rgba(255,255,255,.12)';
  el.style.color = hexColor || '#e7eaf6';
}

function extractRate(raw){
  if (raw == null) return 0;
  if (typeof raw === 'number') return Number.isFinite(raw) ? raw : 0;
  if (typeof raw === 'object'){
    const candidates = [raw.rate_per_s, raw.per_s_10s, raw.per_s_60s, raw.rate, raw.value];
    for (const val of candidates){
      const num = Number(val);
      if (Number.isFinite(num)) return num;
    }
  }
  const num = Number(raw);
  return Number.isFinite(num) ? num : 0;
}

function formatDuration(seconds){
  const s = Number(seconds);
  if (!Number.isFinite(s) || s < 0) return '—';
  if (s < 60) return `${Math.round(s)}s`;
  if (s < 3600){
    const minutes = Math.floor(s / 60);
    const remSeconds = Math.round(s % 60);
    return `${minutes}m ${remSeconds}s`;
  }
  const hours = Math.floor(s / 3600);
  const minutes = Math.floor((s % 3600) / 60);
  const days = Math.floor(hours / 24);
  const remHours = hours % 24;
  if (days > 0) return `${days}d ${remHours}h`;
  return `${hours}h ${minutes}m`;
}

function normalizeSeries(raw){
  if (!Array.isArray(raw)) return [];
  return raw.map(v => Number(v));
}

function normalizeHeightSeries(series, length){
  const len = Number(length) || 0;
  const src = Array.isArray(series) ? series : [];
  const out = new Array(len);
  for (let i = 0; i < len; i++){
    const raw = src[i];
    if (raw == null){
      out[i] = null;
      continue;
    }
    const num = Number(raw);
    out[i] = Number.isFinite(num) ? num : null;
  }
  return out;
}

function toDeltaSeries(series){
  if (!Array.isArray(series) || !series.length) return [];
  let baseline = null;
  return series.map(val => {
    if (!Number.isFinite(val)){
      return null;
    }
    if (baseline === null){
      baseline = val;
      return 0;
    }
    return val - baseline;
  });
}

function transformForMode(key, raw){
  const data = normalizeSeries(raw);
  if (!data.length) return data;
  if (chartModes[key] !== 'delta') return data;
  const baseline = data[0];
  const deltas = data.map(v => v - baseline);
  const hasVariance = deltas.some(v => Math.abs(v) > 1e-9);
  return hasVariance ? deltas : data;
}

function labelFor(key){
  const base = baseChartLabels[key] || 'Series';
  return chartModes[key] === 'delta' ? `${base} Δ` : base;
}

function alignSeriesLength(series, length){
  const out = new Array(length);
  const src = Array.isArray(series) ? series : [];
  for (let i = 0; i < length; i++){
    const num = Number(src[i]);
    out[i] = Number.isFinite(num) ? num : null;
  }
  return out;
}

function deriveRateSeries(labels, totals){
  const len = Math.min(Array.isArray(labels) ? labels.length : 0, Array.isArray(totals) ? totals.length : 0);
  const rates = new Array(len);
  let prevTotal = null;
  let prevTs = null;
  for (let i = 0; i < len; i++){
    const ts = Number(labels[i]);
    const total = Number(totals[i]);
    if (!Number.isFinite(ts) || !Number.isFinite(total)){
      rates[i] = null;
      continue;
    }
    if (prevTotal === null || prevTs === null || ts <= prevTs){
      rates[i] = 0;
    } else {
      const delta = Math.max(total - prevTotal, 0);
      const dt = (ts - prevTs) / 1000;
      rates[i] = dt > 0 ? delta / dt : 0;
    }
    prevTotal = total;
    prevTs = ts;
  }
  while (rates.length < (Array.isArray(labels) ? labels.length : 0)){
    rates.push(null);
  }
  return rates;
}

function updateLineChart(key, labels, rawData){
  const canvasMap = { peers:'peersChart', latency:'latencyChart' };
  const canvasId = canvasMap[key];
  if (!canvasId) return;
  const datasetLabel = labelFor(key);
  const data = transformForMode(key, rawData);
  if (!charts[key]){
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    charts[key] = mkLine(ctx, datasetLabel, data, labels);
  }else{
    const chart = charts[key];
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.data.datasets[0].label = datasetLabel;
    chart.update('none');
  }
  renderChartValue(key, data, datasetLabel);
}

function ensureChartTag(chart, label){
  if (!chart) return null;
  if (chart._valueTag && chart._valueTag.isConnected) return chart._valueTag;
  const canvas = chart.canvas;
  if (!canvas || !canvas.parentElement) return null;
  const wrapper = canvas.parentElement;
  const style = window.getComputedStyle(wrapper);
  if (style.position === 'static'){ wrapper.style.position = 'relative'; }
  const tag = document.createElement('div');
  tag.className = 'chart-value-tag';
  if (label){
    tag.dataset.series = label;
    tag.title = label;
  }
  wrapper.appendChild(tag);
  chart._valueTag = tag;
  return tag;
}

function formatValueDisplay(val){
  if (val == null) return '—';
  if (!Number.isFinite(val)) return '—';
  const abs = Math.abs(val);
  if (abs >= 1000){
    const units = ['','K','M','B','T'];
    let unitIdx = 0;
    let scaled = val;
    while (unitIdx < units.length-1 && Math.abs(scaled) >= 1000){
      scaled /= 1000;
      unitIdx++;
    }
    return `${scaled.toFixed(scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2).replace(/\.?0+$/,'')}${units[unitIdx]}`;
  }
  return val.toFixed(abs >= 100 ? 0 : abs >= 10 ? 1 : 2).replace(/\.?0+$/,'');
}

function renderChartValue(key, data, label){
  const chart = charts[key];
  if (!chart) return;
  const tag = ensureChartTag(chart, label);
  if (!tag) return;
  const latest = data.length ? data[data.length-1] : null;
  tag.textContent = formatValueDisplay(latest);
}

function renderHeightValue(localSeries, remoteSeries){
  const chart = charts.height;
  if (!chart) return;
  const tag = ensureChartTag(chart, 'Height');
  if (!tag) return;
  const pickLatest = (arr) => {
    if (!Array.isArray(arr)) return null;
    for (let i = arr.length - 1; i >= 0; i--){
      const val = arr[i];
      if (Number.isFinite(val)) return val;
    }
    return null;
  };
  const localLatest = pickLatest(localSeries);
  const remoteLatest = pickLatest(remoteSeries);
  const diff = (Number.isFinite(localLatest) && Number.isFinite(remoteLatest)) ? (remoteLatest - localLatest) : null;
  const diffText = Number.isFinite(diff) ? ` · Δ ${formatValueDisplay(diff)}` : '';
  tag.textContent = `L ${formatValueDisplay(localLatest)} · R ${formatValueDisplay(remoteLatest)}${diffText}`;
  tag.title = 'Local vs Remote height · Δ = remote - local';
}

function setNodeControlStatus(msg, ok = true){
  const el = document.getElementById('nodeControlStatus');
  if (!el) return;
  el.textContent = msg || '';
  el.style.color = ok ? 'var(--muted)' : 'var(--bad)';
  el.style.opacity = msg ? 1 : 0;
}

function setNodeControlButtonsDisabled(disabled){
  document.querySelectorAll('#nodeControlsCard [data-node-action]').forEach(btn => {
    btn.disabled = !!disabled;
  });
  const hoursInput = document.getElementById('autoRestartHours');
  if (hoursInput){
    hoursInput.disabled = !!disabled;
  }
}

function setChainControlStatus(msg, ok = true){
  const el = document.getElementById('chainControlStatus');
  if (!el) return;
  el.textContent = msg || '';
  el.style.color = ok ? 'var(--muted)' : 'var(--bad)';
  el.style.opacity = msg ? 1 : 0;
}

function setChainControlButtonsDisabled(disabled){
  document.querySelectorAll('#nodeControlsCard [data-node-action^="chain_"]').forEach(btn => {
    btn.disabled = !!disabled;
  });
  const select = document.getElementById('chainBackupSelect');
  if (select){
    if (disabled){
      select.setAttribute('disabled','disabled');
    } else {
      select.removeAttribute('disabled');
    }
  }
}

function findContainer(name){
  if (!name) return null;
  return (nodeControlState.containers || []).find(item => item && item.name === name) || null;
}

function describeAutoRestart(entry){
  if (!entry || !entry.auto_restart) return 'Auto restart: Disabled';
  const ar = entry.auto_restart;
  if (!ar.installed){
    return 'Auto restart: Disabled';
  }
  const base = ar.interval || (Number.isFinite(ar.interval_hours) ? `${Math.max(1, Math.round(ar.interval_hours))}h` : 'unknown');
  if (ar.enabled){
    if (ar.active){
      return 'Auto restart: Active';
    }
    const state = 'enabled';
    return `Auto restart: every ${base} (${state})`;
  }
  return `Auto restart: every ${base} (disabled)`;
}

function updateNodeContainerDetails(){
  const select = document.getElementById('nodeContainerSelect');
  const details = document.getElementById('nodeContainerDetails');
  const hoursInput = document.getElementById('autoRestartHours');
  if (!details) return;
  if (!select || !select.value){
    details.textContent = 'Auto restart: Disabled';
    if (hoursInput) hoursInput.value = AUTO_RESTART_DEFAULT_HOURS;
    return;
  }
  const entry = findContainer(select.value);
  details.textContent = describeAutoRestart(entry);
  if (hoursInput){
    if (entry && entry.auto_restart && Number.isFinite(entry.auto_restart.interval_hours)){
      const hours = Math.max(1, Math.round(entry.auto_restart.interval_hours));
      hoursInput.value = hours;
    } else {
      hoursInput.value = AUTO_RESTART_DEFAULT_HOURS;
    }
  }
}

function renderNodeControls(errorMsg){
  const card = document.getElementById('nodeControlsCard');
  const select = document.getElementById('nodeContainerSelect');
  const details = document.getElementById('nodeContainerDetails');
  if (!card) return;
  card.hidden = false;
  if (errorMsg){
    if (select){
      select.innerHTML = '<option value=\"\">Unavailable</option>';
      select.disabled = true;
      select.value = '';
    }
    if (details) details.textContent = 'Auto restart: unavailable';
    setNodeControlButtonsDisabled(true);
    if (!nodeControlPendingMessage){
      setNodeControlStatus(errorMsg, false);
    }
    nodeControlState.chainEnabled = false;
    renderChainControls();
    return;
  }
  if (!nodeControlState.enabled){
    if (select){
      select.innerHTML = '<option value=\"\">Controls disabled</option>';
      select.disabled = true;
      select.value = '';
    }
    if (details) details.textContent = 'Auto restart: unavailable';
    setNodeControlButtonsDisabled(true);
    nodeControlState.chainEnabled = false;
    renderChainControls();
    return;
  }
  const containers = Array.isArray(nodeControlState.containers) ? nodeControlState.containers : [];
  if (select){
    const previous = select.value;
    select.innerHTML = '';
    if (!containers.length){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(no containers)';
      select.appendChild(opt);
      select.disabled = true;
      select.value = '';
    } else {
      containers.forEach((item, index) => {
        if (!item || !item.name) return;
        const opt = document.createElement('option');
        opt.value = item.name;
        opt.textContent = item.name;
        if (previous === item.name || (!previous && index === 0)){
          opt.selected = true;
        }
        select.appendChild(opt);
      });
      select.disabled = false;
      if (!select.value && containers.length){
        select.value = containers[0].name;
      }
    }
  }
  const hasContainer = !!(select && select.value);
  setNodeControlButtonsDisabled(!hasContainer);
  updateNodeContainerDetails();
  nodeControlState.chainEnabled = hasContainer;
  renderChainControls();
  if (!hasContainer){
    setNodeControlStatus('No containers detected', false);
  } else if (!nodeControlPendingMessage){
    setNodeControlStatus('');
  }
}

function renderChainControls(){
  const select = document.getElementById('chainBackupSelect');
  const backupBtn = document.getElementById('btnChainBackup');
  const restoreBtn = document.getElementById('btnChainRestore');
  let deleteBtn = document.getElementById('btnChainDelete');
  if (!deleteBtn){
    const actions = document.querySelector('#nodeControlsCard .node-ctrls__actions--chain');
    if (actions){
      deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.id = 'btnChainDelete';
      deleteBtn.dataset.nodeAction = 'chain_delete';
      deleteBtn.textContent = 'Delete Selected';
      deleteBtn.disabled = true;
      const backupReference = document.getElementById('btnChainBackup');
      actions.insertBefore(deleteBtn, backupReference || null);
      deleteBtn.addEventListener('click', ev => {
        ev.preventDefault();
        performNodeAction('chain_delete');
      });
    }
  }
  if (!select || !backupBtn || !restoreBtn || !deleteBtn) return;
  const backups = Array.isArray(nodeControlState.chainBackups) ? nodeControlState.chainBackups : [];
  const previous = select.value;
  select.innerHTML = '';
  if (!backups.length){
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(no backups found)';
    select.appendChild(opt);
    select.disabled = true;
  } else {
    backups.forEach((item, index) => {
      if (!item || !item.name) return;
      const opt = document.createElement('option');
      opt.value = item.name;
      const infoParts = [];
      if (item.modified){
        infoParts.push(formatTimestamp(item.modified));
      }
      if (Number.isFinite(Number(item.size))){
        infoParts.push(formatBytes(item.size));
      }
      const suffix = infoParts.length ? ` — ${infoParts.join(' • ')}` : '';
      opt.textContent = `${item.name}${suffix}`;
      opt.title = suffix ? suffix.replace(/^ —\s*/, '') : item.name;
      if (previous === item.name || (!previous && index === 0)){
        opt.selected = true;
      }
      select.appendChild(opt);
    });
    if (!select.value && backups.length){
      select.value = backups[0].name;
    }
    select.disabled = !nodeControlState.chainEnabled;
  }
  const job = nodeControlState.chainJob || null;
  const inProgress = !!(job && job.active);
  const hasBackups = backups.some(item => item && item.name);
  const jobMessage = buildChainJobMessage(job);
  if (job && job.active && job.type === 'backup'){
    const details = job.details || {};
    const pendingName = formatBackupNameDisplay(details.path);
    const pendingText = jobMessage || `Creating ${pendingName}`;
    const pendingValue = (job.details && job.details.path) || '';
    const pendingOpt = document.createElement('option');
    pendingOpt.value = pendingValue;
    pendingOpt.textContent = pendingText;
    pendingOpt.dataset.pending = '1';
    pendingOpt.disabled = true;
    pendingOpt.selected = true;
    select.insertBefore(pendingOpt, select.firstChild || null);
  }
  if (inProgress){
    setChainControlStatus(jobMessage || job.message || `Chain ${job.type || 'operation'} in progress…`, job.status !== 'error');
    backupBtn.disabled = true;
    restoreBtn.disabled = true;
    deleteBtn.disabled = true;
    select.disabled = true;
  } else {
    const enabled = !!nodeControlState.chainEnabled;
    backupBtn.disabled = !enabled;
    restoreBtn.disabled = !enabled || !select.value || !hasBackups;
    deleteBtn.disabled = !enabled || !select.value || !hasBackups;
    if (job && (jobMessage || job.message)){
      setChainControlStatus(jobMessage || job.message, job.status !== 'error');
    } else if (!enabled){
      setChainControlStatus('Select a container to manage chain backups.', false);
    } else {
      setChainControlStatus(hasBackups ? 'Ready.' : 'No backups found.', hasBackups);
    }
  }
}

async function refreshNodeControls(force = false){
  const now = Date.now();
  if (!force && now - nodeControlState.lastFetched < NODE_CTRL_REFRESH_MS){
    return;
  }
  try{
    const res = await fetch('/api/containers', { cache:'no-store' });
    if (!res.ok){
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    nodeControlState.enabled = !!(data && data.enabled);
    nodeControlState.containers = Array.isArray(data?.containers) ? data.containers : [];
    nodeControlState.lastFetched = Date.now();
    renderNodeControls();
  }catch(err){
    nodeControlState.enabled = false;
    nodeControlState.lastFetched = Date.now();
    console.warn('[node-controls] failed to load containers', err);
    renderNodeControls('Node controls unavailable');
  }
  await refreshChainBackups(force);
}

async function refreshChainBackups(force = false){
  const now = Date.now();
  if (!force && now - (nodeControlState.chainBackupsLastFetched || 0) < NODE_CTRL_REFRESH_MS){
    return;
  }
  try{
    const res = await fetch('/api/chain/backups', { cache:'no-store' });
    if (!res.ok){
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    nodeControlState.chainBackups = Array.isArray(data?.backups) ? data.backups : [];
    nodeControlState.chainJob = data?.job || null;
    nodeControlState.chainBackupsLastFetched = Date.now();
    renderChainControls();
  }catch(err){
    nodeControlState.chainBackups = [];
    nodeControlState.chainJob = { active:false, status:'error', message:'Chain backup info unavailable' };
    nodeControlState.chainBackupsLastFetched = Date.now();
    renderChainControls();
  }
}

async function performNodeAction(action){
  const ACTION_MAP = {
    restart:'docker_restart',
    start:'docker_start',
    stop:'docker_stop',
    auto_enable:'auto_restart_enable',
    auto_disable:'auto_restart_disable',
    chain_backup:'chain_backup',
    chain_restore:'chain_restore',
    chain_delete:'chain_delete',
  };
  const select = document.getElementById('nodeContainerSelect');
  const isChainAction = action === 'chain_backup' || action === 'chain_restore' || action === 'chain_delete';
  const statusSetter = isChainAction ? setChainControlStatus : setNodeControlStatus;
  if (!ACTION_MAP[action]){
    statusSetter('Unsupported action', false);
    return;
  }
  if (!select || !select.value){
    statusSetter('Select a container first', false);
    return;
  }
  const container = select.value;
  const hoursInput = document.getElementById('autoRestartHours');
  const backupSelect = document.getElementById('chainBackupSelect');
  let successLabel = action.charAt(0).toUpperCase() + action.slice(1);
  let statusMessage = `${successLabel} ${container}`;
  const payload = { action: ACTION_MAP[action], container };
  if (action === 'auto_enable'){
    const hoursVal = Number(hoursInput ? hoursInput.value : AUTO_RESTART_DEFAULT_HOURS);
    if (!Number.isFinite(hoursVal) || hoursVal <= 0){
      setNodeControlStatus('Enter auto restart hours ≥ 1', false);
      return;
    }
    payload.hours = hoursVal;
    successLabel = `Auto restart (${hoursVal}h)`;
    statusMessage = `Configuring auto restart (${hoursVal}h) for ${container}`;
  } else if (action === 'auto_disable'){
    successLabel = 'Auto restart disabled';
    statusMessage = `Disabling auto restart for ${container}`;
  } else if (action === 'chain_backup'){
    successLabel = 'Chain backup';
    statusMessage = `Creating chain backup for ${container}`;
  } else if (action === 'chain_restore'){
    if (!backupSelect || !backupSelect.value){
      setChainControlStatus('Select a backup to restore', false);
      return;
    }
    payload.backup = backupSelect.value;
    successLabel = 'Chain restore';
    statusMessage = `Restoring ${backupSelect.value}`;
  } else if (action === 'chain_delete'){
    if (!backupSelect || !backupSelect.value){
      setChainControlStatus('Select a backup to delete', false);
      return;
    }
    payload.backup = backupSelect.value;
    successLabel = 'Chain delete';
    statusMessage = `Deleting ${backupSelect.value}`;
  }
  let finalMessage = '';
  let finalOk = true;
  try{
    setNodeControlButtonsDisabled(true);
    if (isChainAction){
      setChainControlButtonsDisabled(true);
    }
    statusSetter(`${statusMessage}…`);
    const res = await fetch('/api/control', {
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify(payload)
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok || !data || data.ok === false){
      throw new Error((data && data.error) || `Action failed (${res.status})`);
    }
    finalMessage = (data.output || data.message || `${successLabel} succeeded`).trim();
    const lowerMessage = finalMessage.toLowerCase();
    if (action === 'auto_enable' && lowerMessage.includes('setup complete')){
      const setupLine = finalMessage.split('\n').find(line => line.toLowerCase().includes('setup complete'));
      finalMessage = (setupLine || 'Setup complete.').trim();
    } else if (action !== 'auto_enable' && lowerMessage.includes('setup complete')){
      finalMessage = `${successLabel} succeeded`;
    }
    finalOk = true;
  }catch(err){
    finalMessage = err && err.message ? err.message : 'Action failed';
    finalOk = false;
  }finally{
    if (isChainAction){
      chainControlPendingMessage = { text: finalMessage, ok: finalOk };
    } else {
      nodeControlPendingMessage = { text: finalMessage, ok: finalOk };
    }
    nodeControlState.lastFetched = 0;
    try{
      await refreshNodeControls(true);
    }catch(refreshErr){
      console.warn('[node-controls] refresh after action failed', refreshErr);
      renderNodeControls('Node controls unavailable');
    }
    if (isChainAction){
      if (chainControlPendingMessage){
        setChainControlStatus(chainControlPendingMessage.text, chainControlPendingMessage.ok);
        chainControlPendingMessage = null;
      }
    } else if (nodeControlPendingMessage){
      setNodeControlStatus(nodeControlPendingMessage.text, nodeControlPendingMessage.ok);
      nodeControlPendingMessage = null;
    }
  }
}

function wireNodeControls(){
  const card = document.getElementById('nodeControlsCard');
  if (!card) return;
  const select = document.getElementById('nodeContainerSelect');
  if (select){
    select.addEventListener('change', () => {
      updateNodeContainerDetails();
      setNodeControlStatus('');
    });
  }
  document.querySelectorAll('#nodeControlsCard [data-node-action]').forEach(btn => {
    btn.addEventListener('click', ev => {
      ev.preventDefault();
      const action = btn.dataset.nodeAction;
      if (action){
        performNodeAction(action);
      }
    });
  });
  renderNodeControls();
  setNodeControlStatus('Loading containers…');
  setChainControlStatus('Loading chain backups…');
  refreshChainBackups(true);
}

function formatHeightLabel(value){
  const num = Number(value);
  if (Number.isFinite(num) && num > 1e11){
    const date = new Date(num);
    return date.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  if (value === null || value === undefined) return '';
  return String(value);
}

function buildHeightChart(canvas, labels, localDelta, remoteDelta){
  const ctx = canvas.getContext('2d');
  const labelStrings = labels.map(formatHeightLabel);
  const baseTickColor = (window.Chart && window.Chart.defaults && window.Chart.defaults.color) || '#666';
  return new Chart(ctx, {
    type:'line',
    data:{
      labels: labelStrings,
      datasets:[
        {
          label:'Local Height Δ',
          data: localDelta,
          borderColor:'#25d366',
          backgroundColor:'rgba(37,211,102,0.12)',
          fill:false,
          tension:0.25,
          pointRadius:0,
          borderWidth:2,
          spanGaps:true
        },
        {
          label:'Remote Height Δ',
          data: remoteDelta,
          borderColor:'#64b5f6',
          backgroundColor:'rgba(100,181,246,0.1)',
          borderDash:[6,4],
          fill:false,
          tension:0.25,
          pointRadius:0,
          borderWidth:2,
          spanGaps:true
        }
      ]
    },
    options:{
      animation:false,
      responsive:true,
      maintainAspectRatio:false,
      interaction:{ mode:'nearest', intersect:false },
      plugins:{
        legend:{
          display:true,
          labels:{
            color: baseTickColor,
            usePointStyle:true,
            padding:16,
            boxWidth:12,
            boxHeight:12
          }
        },
        legendOffset:{ x:-25 },
        tooltip:{
          mode:'index',
          intersect:false,
          callbacks:{
            label(ctx){
              const label = ctx.dataset?.label ? `${ctx.dataset.label}: ` : '';
              return `${label}${formatValueDisplay(ctx.parsed.y)}`;
            }
          }
        }
      },
      scales:{
        x:{
          ticks:{ display:false, color: baseTickColor },
          grid:{ display:false }
        },
        y:{
          beginAtZero:false,
          ticks:{ color: baseTickColor },
          grid:{ color:'rgba(255,255,255,0.05)' }
        }
      }
    }
  });
}

function updateHeightChart(labels, localSeries, remoteSeries){
  const canvas = document.getElementById('heightChart');
  if (!canvas) return;
  const labelList = Array.isArray(labels) ? labels.slice() : [];
  const len = labelList.length;
  const localData = normalizeHeightSeries(localSeries, len);
  const remoteData = normalizeHeightSeries(remoteSeries, len);
  const localDelta = toDeltaSeries(localData);
  const remoteDelta = toDeltaSeries(remoteData);
  if (charts.height){
    try{ charts.height.destroy(); }catch(_){}
    charts.height = null;
  }
  charts.height = buildHeightChart(canvas, labelList, localDelta, remoteDelta);
  charts.height._valueTag = null;
  renderHeightValue(localData, remoteData);
}

function renderActivityValue(activitySeries, syncSeries){
  const chart = charts.activity;
  if (!chart) return;
  const tag = ensureChartTag(chart, `${activitySeriesLabels.activity} · ${activitySeriesLabels.sync}`);
  if (!tag) return;
  const pickLatest = arr => {
    if (!Array.isArray(arr)) return null;
    for (let i = arr.length - 1; i >= 0; i--){
      const val = arr[i];
      if (Number.isFinite(val)) return val;
    }
    return null;
  };
  const activityLatest = pickLatest(activitySeries);
  const syncLatest = pickLatest(syncSeries);
  const fmt = val => Number.isFinite(val) ? `${formatValueDisplay(val)} blk/s` : '—';
  tag.textContent = `Activity ${fmt(activityLatest)} · Sync ${fmt(syncLatest)}`;
}

function fmtTime(ms){
  const d = new Date(ms);
  return d.toLocaleString();
}

const LOG_LINES_LIMIT = 60;

async function refreshStatus(){
  try{
    const r = await fetch('/api/status', {cache:'no-store'});
    const j = await r.json();
    const pill = document.getElementById('healthLine');
    if (pill){
      const ns = j.node_state || {};
      const base = ns.label || (j.status || j.health || 'Unknown');
      const detailText = ns.detail || ((j.health_text && j.health_text !== 'ok') ? j.health_text : '');
      pill.textContent = detailText ? `${base} · ${detailText}` : base;
      pill.title = pill.textContent;
      const color = ns.color || (j.ok ? '#25d366' : '#ff5370');
      applyPillStyle(pill, color, 0.2);
      if (pill.dataset){ pill.dataset.state = ns.code || ''; }
    }
    const formatInt = (val) => (typeof val === 'number' && Number.isFinite(val) ? val.toLocaleString() : '—');
    const localHeightVal = Number.isFinite(j.height_local) ? j.height_local : (Number.isFinite(j.height) ? j.height : null);
    const remoteHeightVal = Number.isFinite(j.height_remote) ? j.height_remote : null;
    const formatStateSync = (val) => {
      if (typeof val === 'boolean') return val ? 'enabled' : 'disabled';
      if (val === null || typeof val === 'undefined') return 'unknown';
      return String(val);
    };
    const localHeightEl = document.getElementById('vLocalHeight');
    if (localHeightEl){
      localHeightEl.textContent = formatInt(localHeightVal);
    }
    const remoteHeightEl = document.getElementById('vRemoteHeight');
    if (remoteHeightEl){
      remoteHeightEl.textContent = formatInt(remoteHeightVal);
    }
    const stateSyncEl = document.getElementById('vStateSync');
    if (stateSyncEl){
      stateSyncEl.textContent = formatStateSync(j.mining_state_sync);
    }
    const etaEl = document.getElementById('vEtaSync');
    if (etaEl){
      const candidates = [j.node_state?.eta_to_sync_sec, j.eta_to_sync_sec];
      let etaSec = null;
      for (const candidate of candidates){
        if (candidate === null || typeof candidate === 'undefined') continue;
        const num = Number(candidate);
        if (Number.isFinite(num)){
          etaSec = num;
          break;
        }
      }
      if (etaSec === null){
        etaEl.textContent = '—';
      } else if (etaSec <= 0){
        etaEl.textContent = 'synced';
      } else {
        etaEl.textContent = formatDuration(etaSec);
      }
    }
    document.getElementById('vPeers').textContent  = j.peers;
    document.getElementById('vLat').textContent    = j.rpc_latency_ms;
    const lastSeenEl = document.getElementById('vLast');
    if (lastSeenEl){
      const ts = Number(j.last_seen_ts);
      lastSeenEl.textContent = Number.isFinite(ts) ? fmtTime(ts) : '—';
    }
    const actSrc = (j.node_state && j.node_state.activity) || j.activity || {};
    const totalsSrc = (actSrc && typeof actSrc === 'object' && actSrc.totals) || {};
    const minedTotal = Number(totalsSrc?.mined);
    const processedTotal = Number(totalsSrc?.processed);
    const sealedTotal = Number(totalsSrc?.sealed);
    const minedDisplay = Number.isFinite(minedTotal) ? minedTotal : extractRate(actSrc.mined);
    const processedDisplay = Number.isFinite(processedTotal) ? processedTotal : extractRate(actSrc.processed);
    const sealedDisplay = Number.isFinite(sealedTotal) ? sealedTotal : extractRate(actSrc.sealed);
    const fmtActivityValue = (val) => Number.isFinite(val) ? formatValueDisplay(val) : '—';
    document.getElementById('vMined').textContent     = fmtActivityValue(minedDisplay);
    document.getElementById('vProcessed').textContent = fmtActivityValue(processedDisplay);
    document.getElementById('vSealed').textContent    = fmtActivityValue(sealedDisplay);
    const uptimeEl = document.getElementById('vUptime');
    if (uptimeEl){
      const uptime = Number(j.node_state?.uptime_sec ?? j.uptime_sec ?? j.uptime ?? 0);
      uptimeEl.textContent = Number.isFinite(uptime) ? formatDuration(uptime) : '—';
    }
  }catch(e){
    const pill = document.getElementById('healthLine');
    if (pill){
      pill.textContent = 'Unavailable';
      pill.title = 'Status fetch failed';
      applyPillStyle(pill, '#ff5370');
      if (pill.dataset){ pill.dataset.state = 'unreachable'; }
    }
    const lastSeenEl = document.getElementById('vLast');
    if (lastSeenEl){ lastSeenEl.textContent = '—'; }
    const uptimeEl = document.getElementById('vUptime');
    if (uptimeEl){ uptimeEl.textContent = '—'; }
    const etaEl = document.getElementById('vEtaSync');
    if (etaEl){ etaEl.textContent = '—'; }
  }
}

async function refreshLogs(){
  const el = document.getElementById('logOutput');
  if (!el) return;
  const panel = document.getElementById('logsPanel');
  if (panel && !panel.open) return;
  try{
    const res = await fetch(`/api/logs/recent?limit=${LOG_LINES_LIMIT}`, { cache:'no-store' });
    if (!res.ok) throw new Error(res.status || 'logs fetch failed');
    const data = await res.json();
    const lines = Array.isArray(data.lines) ? data.lines : [];
    const text = lines.join('\n');
    if (!text){
      if (el.dataset.lastText !== '--empty--'){
        el.textContent = 'No logs available.';
        el.dataset.lastText = '--empty--';
      }
      return;
    }
    if (el.dataset.lastText !== text){
      el.textContent = text;
      el.dataset.lastText = text;
      el.scrollTop = el.scrollHeight;
    }
  }catch(err){
    el.textContent = 'Failed to load logs';
  }
}

async function refreshCharts(){
  if (!window.Chart) return;
  const fetchJSON = u => fetch(u).then(r=>r.json()).catch(()=>null);
  const [h,p,l,a] = await Promise.all([
    fetchJSON('/api/chart/height'),
    fetchJSON('/api/chart/peers'),
    fetchJSON('/api/chart/latency'),
    fetchJSON('/api/chart/activity'),
  ]);

  if (h){
    updateHeightChart(h.labels || [], h.local || [], h.remote || []);
  }else{
    updateHeightChart([], [], []);
  }
  if (p){
    updateLineChart('peers', p.labels || [], p.data || []);
  }
  if (l){
    updateLineChart('latency', l.labels || [], l.data || []);
  }
  if (a){
    const labels = Array.isArray(a.labels) ? a.labels : [];
    const totalsFallback = Array.isArray(a.total) ? a.total : [];
    const activityRateRaw = Array.isArray(a.activity_rate) ? a.activity_rate
      : Array.isArray(a.rate) ? a.rate
      : deriveRateSeries(labels, totalsFallback);
    const syncRateRaw = Array.isArray(a.sync_rate) ? a.sync_rate
      : Array.isArray(a.height_dx) ? a.height_dx
      : [];
    const activityRateSeries = alignSeriesLength(activityRateRaw, labels.length);
    let syncRateSeries = alignSeriesLength(syncRateRaw, labels.length);
    if (!syncRateSeries.some(v => Number.isFinite(v))){
      const heightSeries = Array.isArray(a.height_local) ? a.height_local : [];
      syncRateSeries = alignSeriesLength(deriveRateSeries(labels, heightSeries), labels.length);
    }
    const ctx = document.getElementById('activityChart')?.getContext('2d');
    if (ctx){
      if (charts.activity && charts.activity.data.datasets.length !== 2){
        try{ charts.activity.destroy(); }catch(_){}
        charts.activity = null;
      }
      if (!charts.activity){
        charts.activity = new Chart(ctx, {
          type:'line',
          data:{
            labels,
            datasets:[
              { label:activitySeriesLabels.activity, data:activityRateSeries, fill:false, tension:0.25, pointRadius:0, borderWidth:2 },
              { label:activitySeriesLabels.sync, data:syncRateSeries, fill:false, tension:0.25, pointRadius:0, borderWidth:2 },
            ]
          },
          options:{
            animation:false, responsive:true, maintainAspectRatio:false,
            scales:{ x:{ ticks:{display:false}}, y:{ beginAtZero:true }},
            plugins:{ legend:{ display:true } }
          }
        });
        charts.activity._valueTag = null;
      }else{
        charts.activity.data.labels = labels;
        charts.activity.data.datasets[0].label = activitySeriesLabels.activity;
        charts.activity.data.datasets[0].data = activityRateSeries;
        charts.activity.data.datasets[1].label = activitySeriesLabels.sync;
        charts.activity.data.datasets[1].data = syncRateSeries;
        charts.activity.update('none');
      }
      renderActivityValue(activityRateSeries, syncRateSeries);
    }
  }else if (charts.activity){
    charts.activity.data.labels = [];
    if (charts.activity.data.datasets.length){
      const ds1 = charts.activity.data.datasets[0];
      if (ds1){
        ds1.label = activitySeriesLabels.activity;
        ds1.data = [];
      }
      const ds2 = charts.activity.data.datasets[1];
      if (ds2){
        ds2.label = activitySeriesLabels.sync;
        ds2.data = [];
      }
    }
    charts.activity.update('none');
    renderActivityValue([], []);
  }
}

async function tick(){
  await refreshStatus();
  await refreshCharts();
  await refreshNodeControls();
}
async function preloadHistory(){
  if (!window.Chart) return;
  try{
    const res = await fetch('/api/history', { cache:'no-store' });
    if (!res.ok) throw new Error(res.status || 'history response not ok');
    const hist = await res.json();
    const labelsFor = key => (hist[key]?.labels) || [];
    const seriesFor = key => (hist[key]?.series) || [];
    const primeLine = key => {
      const labels = labelsFor(key);
      const data = seriesFor(key);
      if (!labels.length) return;
      updateLineChart(key, labels, data);
    };
    primeLine('peers');
    primeLine('latency');

    const heightLabels = labelsFor('height_local');
    if (heightLabels.length){
      updateHeightChart(heightLabels, seriesFor('height_local'), seriesFor('height_remote'));
    }else{
      updateHeightChart([], [], []);
    }

    const actLabels = labelsFor('activity');
    if (actLabels.length){
      const totals = seriesFor('activity').map(v => {
        const num = Number(v);
        return Number.isFinite(num) ? num : null;
      });
      const activityRateSeries = deriveRateSeries(actLabels, totals);
      const syncRates = (() => {
        const heightDxSeries = seriesFor('height_dx').map(v => {
          const num = Number(v);
          return Number.isFinite(num) ? num : null;
        });
        if (heightDxSeries.some(v => Number.isFinite(v))){
          const aligned = alignSeriesLength(heightDxSeries, actLabels.length);
          return aligned.map(v => Number.isFinite(v) ? Math.max(v, 0) : null);
        }
        const heightSeries = seriesFor('height_local').map(v => {
          const num = Number(v);
          return Number.isFinite(num) ? num : null;
        });
        return alignSeriesLength(deriveRateSeries(actLabels, heightSeries), actLabels.length);
      })();
      const ctx = document.getElementById('activityChart')?.getContext('2d');
      if (ctx){
        if (charts.activity && charts.activity.data.datasets.length !== 2){
          try{ charts.activity.destroy(); }catch(_){}
          charts.activity = null;
        }
        if (!charts.activity){
          charts.activity = new Chart(ctx, {
            type:'line',
            data:{
              labels: actLabels,
              datasets:[
                { label:activitySeriesLabels.activity, data:activityRateSeries, fill:false, tension:0.25, pointRadius:0, borderWidth:2 },
                { label:activitySeriesLabels.sync, data:syncRates, fill:false, tension:0.25, pointRadius:0, borderWidth:2 },
              ]
            },
            options:{
              animation:false, responsive:true, maintainAspectRatio:false,
              scales:{ x:{ ticks:{display:false}}, y:{ beginAtZero:true }},
              plugins:{ legend:{ display:true } }
            }
          });
          charts.activity._valueTag = null;
        }else{
          charts.activity.data.labels = actLabels;
          charts.activity.data.datasets[0].label = activitySeriesLabels.activity;
          charts.activity.data.datasets[0].data = activityRateSeries;
          charts.activity.data.datasets[1].label = activitySeriesLabels.sync;
          charts.activity.data.datasets[1].data = syncRates;
          charts.activity.update('none');
        }
        renderActivityValue(activityRateSeries, syncRates);
      }
    }
  }catch(err){
    console.warn('[history] preload failed:', err);
  }
}

function setCtlStatus(msg, ok=true){
  const el = document.getElementById('ctlStatus');
  if (!el) return;
  el.textContent = msg || '';
  el.style.color = ok ? '#25d366' : '#ff5370';
  if (setCtlStatus._timer) clearTimeout(setCtlStatus._timer);
  if (msg){
    setCtlStatus._timer = setTimeout(()=>{ el.textContent = ''; }, 4000);
  }
}

function syncSelectValue(select, value, labelFmt){
  if (!select || value === undefined || value === null) return;
  const str = String(value);
  const hasOption = Array.from(select.options || []).some(opt => opt.value === str);
  if (!hasOption){
    const opt = document.createElement('option');
    opt.value = str;
    opt.textContent = labelFmt ? labelFmt(value) : str;
    opt.dataset.dynamic = '1';
    select.appendChild(opt);
  }
  select.value = str;
}

async function loadChartConfig(){
  try{
    const [cfgRes, statusRes] = await Promise.all([
      fetch('/api/chart/config', { cache:'no-store' }),
      fetch('/api/status', { cache:'no-store' })
    ]);
    if (!cfgRes.ok) throw new Error('config ' + cfgRes.status);
    if (!statusRes.ok) throw new Error('status ' + statusRes.status);
    const cfg = await cfgRes.json();
    const status = await statusRes.json();
    const histInput = document.getElementById('chartHistoryPoints');
    if (histInput && Number.isFinite(cfg.history_len)){
      syncSelectValue(histInput, Math.round(cfg.history_len), v => `${v} pts`);
    }
    const minutesInput = document.getElementById('chartWindowMinutes');
    if (minutesInput && Number.isFinite(status.sample_sec) && Number.isFinite(status.window_points)){
      const minutes = Math.max(1, Math.round((status.window_points * status.sample_sec)/60));
      syncSelectValue(minutesInput, minutes, v => `${v} min`);
    }
  }catch(err){
    setCtlStatus('Failed to load config', false);
  }
}

async function applyWindow(minutes){
  const value = Number(minutes);
  if (!Number.isFinite(value) || value < 1){
    setCtlStatus('Enter minutes ≥ 1', false);
    return null;
  }
  const minutesInt = Math.round(value);
  const res = await fetch('/api/control', {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify({ action:'set_window', minutes: minutesInt })
  });
  const data = await res.json();
  if (!res.ok || !data.ok) throw new Error(data.error || 'set_window failed');
  setCtlStatus(`Window set (${data.minutes || minutesInt} min)`);
  return data;
}

async function applyHistory(points){
  const value = Number(points);
  if (!Number.isFinite(value) || value < 12){
    setCtlStatus('History ≥ 12', false);
    return null;
  }
  const pointsInt = Math.round(value);
  const res = await fetch('/api/chart/config', {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify({ history_len: pointsInt })
  });
  const data = await res.json();
  if (!res.ok || !data.ok) throw new Error(data.error || 'set history failed');
  setCtlStatus(`History set (${data.history_len || pointsInt})`);
  return data;
}

async function applyChartSettings(){
  const input = document.getElementById('chartWindowMinutes');
  const histSelect = document.getElementById('chartHistoryPoints');
  if (!input || !histSelect) return;
  try {
    const minutesVal = input.value;
    const historyVal = histSelect.value;
    await applyWindow(minutesVal);
    await applyHistory(historyVal);
    await preloadHistory();
    await refreshCharts();
    await loadChartConfig();
  } catch(err) {
    setCtlStatus(err.message || 'Apply failed', false);
  }
}

function wireControls(){
  const applyBtn = document.getElementById('btnApplyChartSettings');
  if (applyBtn){
    applyBtn.addEventListener('click', ev => { ev.preventDefault(); applyChartSettings(); });
  }
}

function wireLogsPanel(){
  const panel = document.getElementById('logsPanel');
  if (!panel) return;
  const summary = panel.querySelector('summary');
  const toggleText = summary ? summary.querySelector('.log-toggle-text') : null;
  const icon = summary ? summary.querySelector('.log-toggle-icon') : null;
  const update = () => {
    const open = panel.open;
    if (toggleText){ toggleText.textContent = open ? 'Hide' : 'Show'; }
    if (icon){ icon.textContent = open ? '▼' : '▶'; }
  };
  panel.addEventListener('toggle', update);
  update();
}

const pollMs = Number(window.POLL_INTERVAL || 2000) || 2000;
(async () => {
  wireNodeControls();
  wireControls();
  wireLogsPanel();
  await loadChartConfig();
  await preloadHistory();
  await refreshNodeControls(true);
  await tick();
  await refreshLogs();
  setInterval(tick, pollMs);
  const logsInterval = Math.max(5000, pollMs * 2);
  setInterval(refreshLogs, logsInterval);
})();
</script>
<script>window.POLL_INTERVAL = {{ poll_interval_ms | safe }};</script>
<script src="/config.js"></script>
#nodeControlsCard .node-ctrls--auto-buttons button{min-width:120px}
